package com.powerRanger.ElBuenSabor.entities;

import jakarta.persistence.*;
//import lombok.Data; // Eliminado
import jakarta.validation.constraints.Size;
import java.util.Objects;


// @Data // Eliminado
@Entity
public class ArticuloInsumo extends Articulo {

    @Column(nullable = true)
    @Size(min = 1) // Misma observación que en Articulo para Double
    private Double precioCompra;

    @Column(nullable = true)
    @Size(min = 0)
    private Integer stockActual;

    @Column(nullable = true)
    @Size(min = 0)
    private Integer stockMaximo;

    @Column(nullable = false) // Dejaste nullable = false, asegúrate que siempre tenga valor.
    private Boolean esParaElaborar;

    // Constructores
    public ArticuloInsumo() {
        super();
    }

    public ArticuloInsumo(String denominacion, Double precioVenta, UnidadMedida unidadMedida, Categoria categoria, Boolean estadoActivo, Double precioCompra, Integer stockActual, Integer stockMaximo, Boolean esParaElaborar) {
        super(denominacion, precioVenta, unidadMedida, categoria, estadoActivo);
        this.precioCompra = precioCompra;
        this.stockActual = stockActual;
        this.stockMaximo = stockMaximo;
        this.esParaElaborar = esParaElaborar;
    }

    // Getters y Setters (ya los tenías)
    public Double getPrecioCompra() {
        return precioCompra;
    }

    public void setPrecioCompra(Double precioCompra) {
        this.precioCompra = precioCompra;
    }

    public Integer getStockActual() {
        return stockActual;
    }

    public void setStockActual(Integer stockActual) {
        this.stockActual = stockActual;
    }

    public Integer getStockMaximo() {
        return stockMaximo;
    }

    public void setStockMaximo(Integer stockMaximo) {
        this.stockMaximo = stockMaximo;
    }

    public Boolean getEsParaElaborar() {
        return esParaElaborar;
    }

    public void setEsParaElaborar(Boolean esParaElaborar) {
        this.esParaElaborar = esParaElaborar;
    }

    // equals, hashCode, toString (hereda de Articulo para id, pero podemos sobreescribir si la lógica de negocio lo requiere)
    // Por ahora, usará los de Articulo si no se sobreescriben. Si necesitas una lógica de igualdad específica
    // para ArticuloInsumo que incluya sus propios campos, deberías implementarlos aquí.
    // Ejemplo de toString específico:
    @Override
    public String toString() {
        return "ArticuloInsumo{" +
                "id=" + getId() + // Llama al getter de la superclase
                ", denominacion='" + getDenominacion() + '\'' + // Llama al getter de la superclase
                ", precioCompra=" + precioCompra +
                ", stockActual=" + stockActual +
                ", esParaElaborar=" + esParaElaborar +
                '}';
    }
    // Para equals y hashCode, si la identidad sigue siendo por 'id', los de la superclase Articulo son suficientes.
    // Si ArticuloInsumo tiene su propia identidad o campos clave adicionales para igualdad,
    // entonces sobreescribe equals y hashCode.
    // Ejemplo (si el 'id' sigue siendo la clave primaria para la igualdad):
    // @Override
    // public boolean equals(Object o) {
    //     if (this == o) return true;
    //     if (o == null || getClass() != o.getClass()) return false;
    //     if (!super.equals(o)) return false; // Importante llamar al equals de la superclase
    //     ArticuloInsumo that = (ArticuloInsumo) o;
    //     return Objects.equals(precioCompra, that.precioCompra) && Objects.equals(stockActual, that.stockActual) && Objects.equals(esParaElaborar, that.esParaElaborar);
    // }

    // @Override
    // public int hashCode() {
    //     return Objects.hash(super.hashCode(), precioCompra, stockActual, esParaElaborar);
    // }
    // Dado que Articulo ya implementa equals y hashCode basado en 'id', y ArticuloInsumo es un tipo de Articulo,
    // usualmente no es necesario re-implementarlos a menos que la lógica de igualdad cambie fundamentalmente.
    // Por simplicidad, me atendré a los heredados de Articulo basados en 'id'.

}